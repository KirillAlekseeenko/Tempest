#version 450

#extension GL_EXT_control_flow_attributes:enable

layout(local_size_x = 128) in;

struct IndirectCommand
{
  uint indexCount;
};

struct Descriptor
{
  uint drawId;
  uint ptr;
  uint indSz;
};

struct VkDrawIndexedIndirectCommand
{
  uint indexCount;
  uint instanceCount;
  uint firstIndex;    // prefix sum
  int  vertexOffset;  // can be abused to offset into var_buffer
  uint firstInstance; // caps: should be zero
  uint vboOffset;     // prefix sum
};

layout(binding = 0, std430) restrict buffer EngineInternal0
{
  IndirectCommand cmd[];
} indirectSrc;

layout(binding = 1, std430) restrict buffer EngineInternal1
{
  uint       grow;
  uint       grow2;
  Descriptor desc[];
} mesh;

layout(binding = 2, std430) restrict buffer EngineInternal2
{
  uint grow;
  uint heap[];
} var;

layout(binding = 3, std430) writeonly buffer EngineInternal3
{
    VkDrawIndexedIndirectCommand cmd[];
} indirect;

shared uint partialSummIbo[gl_WorkGroupSize.x];

layout(push_constant, std140) uniform UboPush {
  uint indirectCmdCount;
  };

void main() {
  uint index = gl_LocalInvocationID.x;
  uint len   = indirectCmdCount;

  uint b = ((index+0)*len)/gl_WorkGroupSize.x;
  uint e = ((index+1)*len)/gl_WorkGroupSize.x;

  uint sumIbo = 0;
  [[loop]]
  for(uint i=b; i<e; ++i) {
    sumIbo += indirectSrc.cmd[i].indexCount;
    }
  partialSummIbo[index] = sumIbo;

  memoryBarrierShared();
  barrier();

  uint prefixIbo = 0;
  for(uint i=0; i<index; ++i)
    prefixIbo += partialSummIbo[i];

  memoryBarrierShared();
  barrier();

  const uint grow = var.grow;
  [[loop]]
  for(uint i=b; i<e; ++i) {
    uint indexCount = indirectSrc.cmd[i].indexCount;
    uint firstIndex = grow + prefixIbo;
    uint inst       = indexCount>0 ? 1 : 0;

    prefixIbo += indexCount;

    indirect.cmd[i].indexCount    = 0;
    indirect.cmd[i].instanceCount = inst;
    indirect.cmd[i].firstIndex    = firstIndex;
    indirect.cmd[i].vertexOffset  = 0;
    indirect.cmd[i].firstInstance = 0;
    indirect.cmd[i].vboOffset     = 0;
    }

  barrier();
  // cleanup
  [[branch]]
  if(gl_LocalInvocationIndex==0) {
    mesh.grow2 = 0;
    var.grow   = 0;
    }
  for(uint i=b; i<e; ++i) {
    indirectSrc.cmd[i].indexCount = 0;
    }
  }
